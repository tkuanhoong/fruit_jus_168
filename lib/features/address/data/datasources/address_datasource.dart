import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:fruit_jus_168/features/address/data/models/address.dart';
import 'package:fruit_jus_168/features/address/presentation/bloc/address_bloc.dart';

abstract class AddressDataSource {
  Future<List<AddressModel>> getAddresses();
  Future<AddressModel> getAddress(String addressId);
  Future<void> addAddress(AddressModel address);
  Future<void> editAddress(AddressModel address);
  Future<void> deleteAddress(String addressId);
  Future<void> updateDefaultAddress(String addressId);
}

class FirebaseAddressDataSource implements AddressDataSource {
  final FirebaseFirestore firestore;

  FirebaseAddressDataSource({required this.firestore});

  @override
  Future<List<AddressModel>> getAddresses() async {
    User? user = FirebaseAuth.instance.currentUser;

    if (user != null) {
      final DocumentSnapshot<Map<String, dynamic>> snapshot = await firestore
          .collection('users')
          .doc(user.uid) // Use the UID of the current user
          .get();

      // Access the addresses subcollection
      final addressesCollection = snapshot.reference.collection('addresses');

      // Get the documents from the subcollection
      final QuerySnapshot<Map<String, dynamic>> addressesSnapshot =
          await addressesCollection.get();

      // List to store AddressModels
      List<AddressModel> addressesList = [];

      // Iterate through documents in the addresses subcollection
      for (QueryDocumentSnapshot<Map<String, dynamic>> addressDocument
          in addressesSnapshot.docs) {
        // Convert each document to an AddressModel and add it to the list
        AddressModel addressModel =
            AddressModel.fromMap(addressDocument.data());
        addressesList.add(addressModel);
      }

      return addressesList;
    } else {
      throw Exception('No user logged in');
    }
  }

  @override
  Future<AddressModel> getAddress(String addressId) async {
    User? user = FirebaseAuth.instance.currentUser;

    if (user != null) {
      try {
        DocumentSnapshot<Map<String, dynamic>> userSnapshot =
            await firestore.collection('users').doc(user.uid).get();

        CollectionReference<Map<String, dynamic>> addressesCollection =
            userSnapshot.reference.collection('addresses');

        DocumentSnapshot<Map<String, dynamic>> addressDocument =
            await addressesCollection.doc(addressId).get();

        if (addressDocument.exists) {
          // Convert the document data to an AddressModel and return it
          AddressModel addressModel =
              AddressModel.fromMap(addressDocument.data()!);
          return addressModel;
        } else {
          // Handle the case where the address with the given ID doesn't exist
          throw Exception('Address not found');
        }
      } catch (e) {
        // Handle errors appropriately
        throw Exception('Failed to get address: $e');
      }
    } else {
      // Handle the case where no user is currently logged in
      throw Exception('No user logged in');
    }
  }

  @override
  Future<void> addAddress(AddressModel address) async {
    User? user = FirebaseAuth.instance.currentUser;

    if (user != null) {
      try {
        // Check if the user document exists
        DocumentSnapshot<Map<String, dynamic>> userSnapshot =
            await firestore.collection('users').doc(user.uid).get();

        if (userSnapshot.exists) {
          // Access the addresses subcollection
          CollectionReference<Map<String, dynamic>> addressesCollection =
              firestore
                  .collection('users')
                  .doc(user.uid)
                  .collection('addresses');

          // Add the address to the subcollection and get the ID
          DocumentReference<Map<String, dynamic>> addedDocument =
              await addressesCollection.add(address.toMap());

          // Get the ID generated by Firestore
          String addressId = addedDocument.id;

          // Update the address with the generated ID
          await addressesCollection.doc(addressId).update({'id': addressId});
        } else {
          // If the user document doesn't exist, create it along with the addresses subcollection
          await firestore.collection('users').doc(user.uid).set({});
          DocumentReference<Map<String, dynamic>> addedDocument =
              await firestore
                  .collection('users')
                  .doc(user.uid)
                  .collection('addresses')
                  .add(address.toMap());

          // Get the ID generated by Firestore
          String addressId = addedDocument.id;
          // Access the addresses subcollection
          CollectionReference<Map<String, dynamic>> addressesCollection =
              firestore
                  .collection('users')
                  .doc(user.uid)
                  .collection('addresses');
          // Update the address with the generated ID
          await addressesCollection.doc(addressId).update({'id': addressId});
        }
      } catch (e) {
        throw Exception('Failed to add address: $e');
      }
    } else {
      throw Exception('No user logged in');
    }
  }

  @override
  Future<void> editAddress(AddressModel address) async {
    User? user = FirebaseAuth.instance.currentUser;

    if (user != null) {
      try {
        // Access the addresses subcollection
        CollectionReference<Map<String, dynamic>> addressesCollection =
            firestore.collection('users').doc(user.uid).collection('addresses');

        // Access the specific document using addressId and update its data
        await addressesCollection.doc(address.id).update(address.toMap());
      } catch (e) {
        throw Exception('Failed to edit address: $e');
      }
    } else {
      throw Exception('No user logged in');
    }
  }

  @override
  Future<void> deleteAddress(String addressId) async {
    User? user = FirebaseAuth.instance.currentUser;

    if (user != null) {
      try {
        // Access the addresses subcollection
        CollectionReference<Map<String, dynamic>> addressesCollection =
            firestore.collection('users').doc(user.uid).collection('addresses');

        // Access the specific document using addressId and delete it
        await addressesCollection.doc(addressId).delete();
      } catch (e) {
        throw Exception('Failed to delete address: $e');
      }
    } else {
      throw Exception('No user logged in');
    }
  }

  @override
  Future<void> updateDefaultAddress(String addressId) async {
    User? user = FirebaseAuth.instance.currentUser;

    if (user != null) {
      try {
        // Access the addresses subcollection
        CollectionReference<Map<String, dynamic>> addressesCollection =
            firestore.collection('users').doc(user.uid).collection('addresses');

        // Get all documents in the addresses subcollection
        QuerySnapshot<Map<String, dynamic>> addressesSnapshot =
            await addressesCollection.get();

        // Update isDefault property of all addresses to false
        for (QueryDocumentSnapshot<Map<String, dynamic>> addressDocument
            in addressesSnapshot.docs) {
          await addressDocument.reference.update({'isDefault': false});
        }

        // Update isDefault property of the specified address to true
        await addressesCollection.doc(addressId).update({'isDefault': true});
      } catch (e) {
        throw Exception('Failed to update default address: $e');
      }
    } else {
      throw Exception('No user logged in');
    }
  }
}
